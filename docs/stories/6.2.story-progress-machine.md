# Story 6.2: Create Story Progress State Machine

## Status

Draft

## Story

**As a** developer,
**I want** to build an XState machine that manages story progression and checkpoint tracking,
**so that** the narrative state is maintainable and persistent.

## Acceptance Criteria

1. `StoryProgressMachine` is created in `/machines/story-progress/storyProgressMachine.ts`
2. Machine has states representing story checkpoints: `intro`, `checkpoint1`, `checkpoint2`, `checkpoint3`, `finale`
3. Machine manages context: current checkpoint, games completed, story milestones unlocked
4. Machine handles events: `GAME_COMPLETED`, `CHECKPOINT_REACHED`, `STORY_RESET`
5. Progression logic: advance checkpoint every N games completed (e.g., every 5-7 games)
6. Machine persists state to IndexedDB so story resumes across sessions
7. Machine is visualizable in XState Inspector
8. Unit tests verify checkpoint progression logic

## Tasks / Subtasks

- [ ] Create StoryProgressMachine file structure (AC: 1)
  - [ ] Create directory `/machines/story-progress/`
  - [ ] Create file `storyProgressMachine.ts`
  - [ ] Create `types.ts` for machine-specific types
  - [ ] Create `storyProgressMachine.test.ts` for tests
  - [ ] Create `index.ts` for exports

- [ ] Define machine states and transitions (AC: 2)
  - [ ] Define states:
    - `intro`: Initial story introduction
    - `playing`: Active gameplay (between checkpoints)
    - `checkpoint1`: First milestone (after ~5 games)
    - `checkpoint2`: Second milestone (after ~10 games)
    - `checkpoint3`: Third milestone (after ~15 games)
    - `finale`: Story completion (all words mastered)
  - [ ] Define state transitions with guards
  - [ ] Add always transitions for automatic progression

- [ ] Define machine context (AC: 3)
  - [ ] Create context interface:
    ```typescript
    interface StoryProgressContext {
      currentCheckpoint: number          // 0-4 (intro to finale)
      gamesCompleted: number
      totalGamesInSession: number
      checkpointsUnlocked: number[]      // [0, 1, 2, ...]
      lastCheckpointAt: number           // games count when last checkpoint reached
      storyTheme: string                 // 'space', 'treasure', etc.
      sessionStartTime: Date
    }
    ```
  - [ ] Initialize with default values

- [ ] Define machine events (AC: 4)
  - [ ] Create event types:
    ```typescript
    type StoryProgressEvent =
      | { type: 'GAME_COMPLETED' }
      | { type: 'CHECKPOINT_REACHED'; checkpoint: number }
      | { type: 'CONTINUE_STORY' }
      | { type: 'SKIP_CHECKPOINT' }
      | { type: 'STORY_RESET' }
      | { type: 'FINALE_REACHED' }
    ```

- [ ] Implement progression logic (AC: 5)
  - [ ] Define checkpoint triggers:
    - Checkpoint 1: After 5 games
    - Checkpoint 2: After 10 games
    - Checkpoint 3: After 15 games
    - Finale: When all words reach >80% confidence
  - [ ] Create guard: `shouldTriggerCheckpoint`
  - [ ] Create action: `incrementGamesCompleted`
  - [ ] Create action: `unlockCheckpoint`

- [ ] Implement machine definition (AC: 2, 3, 4, 5)
  - [ ] Define full XState v5 machine:
    ```typescript
    export const storyProgressMachine = createMachine({
      id: 'storyProgress',
      initial: 'intro',
      context: {
        currentCheckpoint: 0,
        gamesCompleted: 0,
        totalGamesInSession: 20,
        checkpointsUnlocked: [0],
        lastCheckpointAt: 0,
        storyTheme: 'space',
        sessionStartTime: new Date()
      },
      states: {
        intro: {
          on: {
            CONTINUE_STORY: 'playing'
          }
        },
        playing: {
          on: {
            GAME_COMPLETED: {
              actions: 'incrementGamesCompleted'
            }
          },
          always: [
            {
              guard: 'shouldReachCheckpoint1',
              target: 'checkpoint1'
            },
            {
              guard: 'shouldReachCheckpoint2',
              target: 'checkpoint2'
            },
            {
              guard: 'shouldReachCheckpoint3',
              target: 'checkpoint3'
            },
            {
              guard: 'shouldReachFinale',
              target: 'finale'
            }
          ]
        },
        checkpoint1: {
          entry: 'unlockCheckpoint1',
          on: {
            CONTINUE_STORY: 'playing',
            SKIP_CHECKPOINT: 'playing'
          }
        },
        checkpoint2: {
          entry: 'unlockCheckpoint2',
          on: {
            CONTINUE_STORY: 'playing',
            SKIP_CHECKPOINT: 'playing'
          }
        },
        checkpoint3: {
          entry: 'unlockCheckpoint3',
          on: {
            CONTINUE_STORY: 'playing',
            SKIP_CHECKPOINT: 'playing'
          }
        },
        finale: {
          type: 'final'
        }
      }
    })
    ```

- [ ] Implement guards (AC: 5)
  - [ ] `shouldReachCheckpoint1`: `gamesCompleted >= 5 && currentCheckpoint < 1`
  - [ ] `shouldReachCheckpoint2`: `gamesCompleted >= 10 && currentCheckpoint < 2`
  - [ ] `shouldReachCheckpoint3`: `gamesCompleted >= 15 && currentCheckpoint < 3`
  - [ ] `shouldReachFinale`: Check if all words have >80% confidence

- [ ] Implement actions
  - [ ] `incrementGamesCompleted`: Increment context counter
  - [ ] `unlockCheckpoint1/2/3`: Add checkpoint to unlocked array, update currentCheckpoint

- [ ] Implement IndexedDB persistence (AC: 6)
  - [ ] Create `/lib/storage/story-progress-storage.ts`
  - [ ] Implement `saveStoryProgress(context)`
  - [ ] Implement `loadStoryProgress(): Promise<StoryProgressContext | null>`
  - [ ] Auto-save context on state transitions
  - [ ] Load persisted state on machine initialization

- [ ] Enable XState Inspector integration (AC: 7)
  - [ ] Add machine ID: `'storyProgress'`
  - [ ] Ensure machine is visible in Inspector
  - [ ] Test state transitions in Inspector UI
  - [ ] Verify context updates appear correctly

- [ ] Create React hook for machine
  - [ ] Create `/hooks/useStoryProgress.ts`:
    ```typescript
    export function useStoryProgress() {
      const [state, send] = useMachine(storyProgressMachine)

      return {
        currentCheckpoint: state.context.currentCheckpoint,
        gamesCompleted: state.context.gamesCompleted,
        isAtCheckpoint: state.matches('checkpoint1') ||
                       state.matches('checkpoint2') ||
                       state.matches('checkpoint3'),
        isFinale: state.matches('finale'),
        completeGame: () => send({ type: 'GAME_COMPLETED' }),
        continueStory: () => send({ type: 'CONTINUE_STORY' }),
        skipCheckpoint: () => send({ type: 'SKIP_CHECKPOINT' })
      }
    }
    ```

- [ ] Create comprehensive unit tests (AC: 8)
  - [ ] Create test file `storyProgressMachine.test.ts`
  - [ ] Test: Machine initializes in `intro` state
  - [ ] Test: Transitions to `playing` on CONTINUE_STORY
  - [ ] Test: Reaches checkpoint1 after 5 games
  - [ ] Test: Reaches checkpoint2 after 10 games
  - [ ] Test: Reaches checkpoint3 after 15 games
  - [ ] Test: Doesn't skip checkpoints
  - [ ] Test: Persists to IndexedDB correctly
  - [ ] Test: Loads from IndexedDB correctly
  - [ ] Run tests with `npm run test`

## Dev Notes

### Architecture Context

[Source: docs/ui-architecture.md#StoryProgressMachine]

**Machine Pattern:**
```typescript
// machines/story-progress/storyProgressMachine.ts
import { createMachine, assign } from 'xstate'

export const storyProgressMachine = createMachine({
  id: 'storyProgress',
  initial: 'intro',
  context: {
    currentCheckpoint: 0,
    gamesCompleted: 0,
    checkpointsUnlocked: [0]
  },
  states: {
    intro: {
      on: { CONTINUE_STORY: 'playing' }
    },
    playing: {
      on: {
        GAME_COMPLETED: {
          actions: assign({
            gamesCompleted: ({ context }) => context.gamesCompleted + 1
          })
        }
      },
      always: [
        {
          guard: ({ context }) => context.gamesCompleted >= 5 && context.currentCheckpoint === 0,
          target: 'checkpoint1'
        }
        // ... more guards
      ]
    },
    checkpoint1: {
      entry: assign({
        currentCheckpoint: 1,
        checkpointsUnlocked: ({ context }) => [...context.checkpointsUnlocked, 1]
      }),
      on: {
        CONTINUE_STORY: 'playing'
      }
    }
    // ... more states
  }
})
```

**Integration with GameSessionMachine:**
```typescript
// GameSessionMachine will spawn StoryProgressMachine as child
export const gameSessionMachine = createMachine({
  context: {
    storyProgress: null
  },
  states: {
    loading: {
      entry: assign({
        storyProgress: ({ spawn }) => spawn(storyProgressMachine)
      })
    },
    playingGame: {
      exit: ({ context }) => {
        // Notify story machine that game completed
        context.storyProgress.send({ type: 'GAME_COMPLETED' })
      }
    }
  }
})
```

**Persistence Pattern:**
```typescript
// Auto-save on context changes
export const storyProgressMachine = createMachine({
  // ... config
  on: {
    '*': {
      actions: ({ context }) => {
        saveStoryProgress(context)
      }
    }
  }
})
```

### Dependencies

**Required:**
- Story 6.1 (Story Theme Assets) - Provides theme information
- XState v5 - State machine library
- IndexedDB - For persistence

**Enables:**
- Story 6.4 (Integrate Checkpoints) - Will use this machine
- Story 6.5 (Intro/Finale Screens) - Will query machine state

### Testing

[Source: docs/ui-architecture.md#XState Machine Testing]

**Test Scenarios:**
```typescript
import { describe, it, expect } from 'vitest'
import { createActor } from 'xstate'
import { storyProgressMachine } from './storyProgressMachine'

describe('StoryProgressMachine', () => {
  it('starts in intro state', () => {
    const actor = createActor(storyProgressMachine)
    actor.start()

    expect(actor.getSnapshot().matches('intro')).toBe(true)
    expect(actor.getSnapshot().context.gamesCompleted).toBe(0)
  })

  it('advances to checkpoint1 after 5 games', () => {
    const actor = createActor(storyProgressMachine)
    actor.start()

    actor.send({ type: 'CONTINUE_STORY' })

    // Complete 5 games
    for (let i = 0; i < 5; i++) {
      actor.send({ type: 'GAME_COMPLETED' })
    }

    expect(actor.getSnapshot().matches('checkpoint1')).toBe(true)
    expect(actor.getSnapshot().context.currentCheckpoint).toBe(1)
  })

  it('persists state to IndexedDB', async () => {
    const actor = createActor(storyProgressMachine)
    actor.start()

    actor.send({ type: 'CONTINUE_STORY' })
    actor.send({ type: 'GAME_COMPLETED' })

    await waitFor(() => {
      const saved = await loadStoryProgress()
      expect(saved?.gamesCompleted).toBe(1)
    })
  })
})
```

**Run Tests:**
```bash
npm run test
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.0 | Initial story created | Sarah (PO) |

## Dev Agent Record

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes List

_To be populated by dev agent_

### File List

_To be populated by dev agent_

## QA Results

_To be populated by QA agent_
