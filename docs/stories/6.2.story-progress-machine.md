# Story 6.2: Create Story Progress State Machine

## Status

Approved

## Story

**As a** developer,
**I want** to build an XState machine that manages story progression and checkpoint tracking,
**so that** the narrative state is maintainable and persistent.

## Acceptance Criteria

1. `StoryProgressMachine` is created in `lib/story/machines/storyProgressMachine.ts`
2. Machine has states representing story checkpoints: `intro`, `checkpoint1`, `checkpoint2`, `checkpoint3`, `finale`
3. Machine manages context: current checkpoint, games completed, story milestones unlocked
4. Machine handles events: `GAME_COMPLETED`, `CHECKPOINT_REACHED`, `STORY_RESET`
5. Progression logic: advance checkpoint every N games completed (e.g., every 5-7 games)
6. Machine persists state to localStorage so story resumes across sessions
7. Machine is visualizable in XState Inspector
8. Unit tests verify checkpoint progression logic

## Tasks / Subtasks

- [ ] Create StoryProgressMachine file structure (AC: 1)
  - [ ] Create directory `lib/story/machines/` (if not exists)
  - [ ] Create file `lib/story/machines/storyProgressMachine.ts`
  - [ ] Add types to `types/story.ts` (follow coding standards)
  - [ ] Create `lib/story/machines/storyProgressMachine.test.ts` for tests
  - [ ] Create `lib/story/machines/index.ts` for exports

- [ ] Define machine states and transitions (AC: 2)
  - [ ] Define states:
    - `intro`: Initial story introduction
    - `playing`: Active gameplay (between checkpoints)
    - `checkpoint1`: First milestone (after ~5 games)
    - `checkpoint2`: Second milestone (after ~10 games)
    - `checkpoint3`: Third milestone (after ~15 games)
    - `finale`: Story completion (all words mastered)
  - [ ] Define state transitions with guards
  - [ ] Add always transitions for automatic progression

- [ ] Define machine context (AC: 3)
  - [ ] Create context interface:
    ```typescript
    interface StoryProgressContext {
      currentCheckpoint: number          // 0-4 (intro to finale)
      gamesCompleted: number
      totalGamesInSession: number
      checkpointsUnlocked: number[]      // [0, 1, 2, ...]
      lastCheckpointAt: number           // games count when last checkpoint reached
      storyTheme: string                 // 'space', 'treasure', etc.
      sessionStartTime: Date
    }
    ```
  - [ ] Initialize with default values

- [ ] Define machine events (AC: 4)
  - [ ] Create event types:
    ```typescript
    type StoryProgressEvent =
      | { type: 'GAME_COMPLETED' }
      | { type: 'CHECKPOINT_REACHED'; checkpoint: number }
      | { type: 'CONTINUE_STORY' }
      | { type: 'SKIP_CHECKPOINT' }
      | { type: 'STORY_RESET' }
      | { type: 'FINALE_REACHED' }
    ```

- [ ] Implement progression logic (AC: 5)
  - [ ] Define checkpoint triggers:
    - Checkpoint 1: After 5 games
    - Checkpoint 2: After 10 games
    - Checkpoint 3: After 15 games
    - Finale: When all words reach >80% confidence
  - [ ] Create guard: `shouldTriggerCheckpoint`
  - [ ] Create action: `incrementGamesCompleted`
  - [ ] Create action: `unlockCheckpoint`

- [ ] Implement machine definition (AC: 2, 3, 4, 5)
  - [ ] Define full XState v5 machine:
    ```typescript
    export const storyProgressMachine = createMachine({
      id: 'storyProgress',
      initial: 'intro',
      context: {
        currentCheckpoint: 0,
        gamesCompleted: 0,
        totalGamesInSession: 20,
        checkpointsUnlocked: [0],
        lastCheckpointAt: 0,
        storyTheme: 'space',
        sessionStartTime: new Date()
      },
      states: {
        intro: {
          on: {
            CONTINUE_STORY: 'playing'
          }
        },
        playing: {
          on: {
            GAME_COMPLETED: {
              actions: 'incrementGamesCompleted'
            }
          },
          always: [
            {
              guard: 'shouldReachCheckpoint1',
              target: 'checkpoint1'
            },
            {
              guard: 'shouldReachCheckpoint2',
              target: 'checkpoint2'
            },
            {
              guard: 'shouldReachCheckpoint3',
              target: 'checkpoint3'
            },
            {
              guard: 'shouldReachFinale',
              target: 'finale'
            }
          ]
        },
        checkpoint1: {
          entry: 'unlockCheckpoint1',
          on: {
            CONTINUE_STORY: 'playing',
            SKIP_CHECKPOINT: 'playing'
          }
        },
        checkpoint2: {
          entry: 'unlockCheckpoint2',
          on: {
            CONTINUE_STORY: 'playing',
            SKIP_CHECKPOINT: 'playing'
          }
        },
        checkpoint3: {
          entry: 'unlockCheckpoint3',
          on: {
            CONTINUE_STORY: 'playing',
            SKIP_CHECKPOINT: 'playing'
          }
        },
        finale: {
          type: 'final'
        }
      }
    })
    ```

- [ ] Implement guards (AC: 5)
  - [ ] `shouldReachCheckpoint1`: `gamesCompleted >= 5 && currentCheckpoint < 1`
  - [ ] `shouldReachCheckpoint2`: `gamesCompleted >= 10 && currentCheckpoint < 2`
  - [ ] `shouldReachCheckpoint3`: `gamesCompleted >= 15 && currentCheckpoint < 3`
  - [ ] `shouldReachFinale`: Check if all words have >80% confidence

- [ ] Implement actions
  - [ ] `incrementGamesCompleted`: Increment context counter
  - [ ] `unlockCheckpoint1/2/3`: Add checkpoint to unlocked array, update currentCheckpoint

- [ ] Implement localStorage persistence (AC: 6)
  - [ ] Use existing `lib/storage/story-progress-storage.ts` or create if missing
  - [ ] Implement `saveStoryProgress(context)` using localStorage
  - [ ] Implement `loadStoryProgress(): StoryProgressContext | null` (synchronous)
  - [ ] Follow storage abstraction pattern from `lib/storage/localStorage.ts`
  - [ ] Auto-save context on state transitions
  - [ ] Load persisted state on machine initialization

- [ ] Enable XState Inspector integration (AC: 7)
  - [ ] Add machine ID: `'storyProgress'`
  - [ ] Ensure machine is visible in Inspector
  - [ ] Test state transitions in Inspector UI
  - [ ] Verify context updates appear correctly

- [ ] Create React hook for machine
  - [ ] Create `lib/story/useStoryProgress.ts`:
    ```typescript
    export function useStoryProgress() {
      const [state, send] = useMachine(storyProgressMachine)

      return {
        currentCheckpoint: state.context.currentCheckpoint,
        gamesCompleted: state.context.gamesCompleted,
        isAtCheckpoint: state.matches('checkpoint1') ||
                       state.matches('checkpoint2') ||
                       state.matches('checkpoint3'),
        isFinale: state.matches('finale'),
        completeGame: () => send({ type: 'GAME_COMPLETED' }),
        continueStory: () => send({ type: 'CONTINUE_STORY' }),
        skipCheckpoint: () => send({ type: 'SKIP_CHECKPOINT' })
      }
    }
    ```

- [ ] Create comprehensive unit tests (AC: 8)
  - [ ] Create test file `lib/story/machines/storyProgressMachine.test.ts`
  - [ ] Test: Machine initializes in `intro` state
  - [ ] Test: Transitions to `playing` on CONTINUE_STORY
  - [ ] Test: Reaches checkpoint1 after 5 games
  - [ ] Test: Reaches checkpoint2 after 10 games
  - [ ] Test: Reaches checkpoint3 after 15 games
  - [ ] Test: Doesn't skip checkpoints
  - [ ] Test: Persists to localStorage correctly
  - [ ] Test: Loads from localStorage correctly
  - [ ] Run tests with `pnpm test`

## Dev Notes

### Architecture Context

**XState Version:** 5.x (confirmed in tech stack)

**Project Structure:**
```
lib/
├── story/
│   ├── assets.ts           # Existing (Story 6.1)
│   ├── content.ts          # Existing (Story 6.1)
│   ├── machines/           # NEW - Create this directory
│   │   ├── storyProgressMachine.ts    # NEW - Main machine
│   │   ├── storyProgressMachine.test.ts  # NEW - Tests
│   │   └── index.ts        # NEW - Exports
│   └── useStoryProgress.ts # NEW - React hook
```

**Machine Pattern:**
```typescript
// lib/story/machines/storyProgressMachine.ts
import { createMachine, assign } from 'xstate'

export const storyProgressMachine = createMachine({
  id: 'storyProgress',
  initial: 'intro',
  context: {
    currentCheckpoint: 0,
    gamesCompleted: 0,
    checkpointsUnlocked: [0]
  },
  states: {
    intro: {
      on: { CONTINUE_STORY: 'playing' }
    },
    playing: {
      on: {
        GAME_COMPLETED: {
          actions: assign({
            gamesCompleted: ({ context }) => context.gamesCompleted + 1
          })
        }
      },
      always: [
        {
          guard: ({ context }) => context.gamesCompleted >= 5 && context.currentCheckpoint === 0,
          target: 'checkpoint1'
        }
        // ... more guards
      ]
    },
    checkpoint1: {
      entry: assign({
        currentCheckpoint: 1,
        checkpointsUnlocked: ({ context }) => [...context.checkpointsUnlocked, 1]
      }),
      on: {
        CONTINUE_STORY: 'playing'
      }
    }
    // ... more states
  }
})
```

**Integration with GameSessionMachine:**
```typescript
// GameSessionMachine will spawn StoryProgressMachine as child
export const gameSessionMachine = createMachine({
  context: {
    storyProgress: null
  },
  states: {
    loading: {
      entry: assign({
        storyProgress: ({ spawn }) => spawn(storyProgressMachine)
      })
    },
    playingGame: {
      exit: ({ context }) => {
        // Notify story machine that game completed
        context.storyProgress.send({ type: 'GAME_COMPLETED' })
      }
    }
  }
})
```

**Persistence Pattern (localStorage):**
```typescript
// lib/storage/story-progress-storage.ts
import type { StoryProgressContext } from '@/types/story'

const STORAGE_KEY = 'wordcraft_story_progress'

export function saveStoryProgress(context: StoryProgressContext): void {
  if (typeof window === 'undefined') return // SSR safety

  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(context))
  } catch (error) {
    console.error('Error saving story progress:', error)
  }
}

export function loadStoryProgress(): StoryProgressContext | null {
  if (typeof window === 'undefined') return null

  try {
    const stored = localStorage.getItem(STORAGE_KEY)
    if (!stored) return null

    const context = JSON.parse(stored)
    // Convert date strings back to Date objects
    return {
      ...context,
      sessionStartTime: new Date(context.sessionStartTime)
    }
  } catch (error) {
    console.error('Error loading story progress:', error)
    return null
  }
}

// Auto-save on state transitions
export const storyProgressMachine = createMachine({
  // ... config
  on: {
    '*': {
      actions: ({ context }) => {
        saveStoryProgress(context)
      }
    }
  }
})
```

**Confidence Scoring Integration:**
```typescript
// For shouldReachFinale guard
import { getMasteredWords, calculateWordConfidence } from '@/lib/algorithms/confidence-scoring'
import { getAllGameResults } from '@/lib/storage/sessionStorage'

// In guard implementation:
guard: ({ context }) => {
  const results = getAllGameResults()
  const allWords = /* get from word list */
  const confidenceMap = new Map(
    allWords.map(word => [
      word,
      calculateWordConfidence(word, results)
    ])
  )
  const masteredWords = getMasteredWords(confidenceMap)
  return masteredWords.length === allWords.length
}
```

### Dependencies

**Required:**
- Story 6.1 (Story Theme Assets) - Provides theme information
- XState v5 - State machine library (confirmed in tech stack)
- localStorage - For persistence (existing storage pattern)
- Confidence scoring algorithms - `lib/algorithms/confidence-scoring.ts` (already exists)

**Integration Points:**
- `lib/algorithms/confidence-scoring.ts` - For finale guard (getMasteredWords)
- `lib/storage/sessionStorage.ts` - For accessing game results (getAllGameResults)
- `types/story.ts` - Add StoryProgressContext and StoryProgressEvent types

**Enables:**
- Story 6.4 (Integrate Checkpoints) - Will use this machine
- Story 6.5 (Intro/Finale Screens) - Will query machine state

**Note on GameSessionMachine:**
The Dev Notes show integration with `GameSessionMachine`, but this doesn't currently exist in the codebase. This is a future integration point and should not block this story.

### Testing

**Testing Standards from Architecture:**

**Framework:** Vitest (confirmed in tech stack)

**Test File Location:** `lib/story/machines/storyProgressMachine.test.ts`

**Testing Patterns:**
- XState machine testing with `createActor` from `xstate`
- Import test utilities from `vitest`: `describe`, `it`, `expect`
- Test all state transitions, guards, and actions
- Test persistence to localStorage
- Mock localStorage for SSR-safe testing

**Coverage Requirements:**
- All state transitions must be tested
- All guards must be tested
- All actions must be tested
- localStorage integration must be tested

**Test Scenarios:**
```typescript
import { describe, it, expect, beforeEach } from 'vitest'
import { createActor } from 'xstate'
import { storyProgressMachine } from './storyProgressMachine'
import { loadStoryProgress, saveStoryProgress } from '@/lib/storage/story-progress-storage'

describe('StoryProgressMachine', () => {
  beforeEach(() => {
    // Clear localStorage before each test
    localStorage.clear()
  })

  it('starts in intro state', () => {
    const actor = createActor(storyProgressMachine)
    actor.start()

    expect(actor.getSnapshot().matches('intro')).toBe(true)
    expect(actor.getSnapshot().context.gamesCompleted).toBe(0)
  })

  it('advances to checkpoint1 after 5 games', () => {
    const actor = createActor(storyProgressMachine)
    actor.start()

    actor.send({ type: 'CONTINUE_STORY' })

    // Complete 5 games
    for (let i = 0; i < 5; i++) {
      actor.send({ type: 'GAME_COMPLETED' })
    }

    expect(actor.getSnapshot().matches('checkpoint1')).toBe(true)
    expect(actor.getSnapshot().context.currentCheckpoint).toBe(1)
  })

  it('persists state to localStorage', () => {
    const actor = createActor(storyProgressMachine)
    actor.start()

    actor.send({ type: 'CONTINUE_STORY' })
    actor.send({ type: 'GAME_COMPLETED' })

    // Check localStorage was updated (synchronous)
    const saved = loadStoryProgress()
    expect(saved?.gamesCompleted).toBe(1)
  })

  it('loads persisted state on initialization', () => {
    // Save state to localStorage
    const context = {
      currentCheckpoint: 1,
      gamesCompleted: 5,
      totalGamesInSession: 20,
      checkpointsUnlocked: [0, 1],
      lastCheckpointAt: 5,
      storyTheme: 'space',
      sessionStartTime: new Date()
    }
    saveStoryProgress(context)

    // Create new machine instance (should load persisted state)
    const loaded = loadStoryProgress()
    expect(loaded?.gamesCompleted).toBe(5)
    expect(loaded?.currentCheckpoint).toBe(1)
  })
})
```

**Run Tests:**
```bash
pnpm test
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.1 | Fixed storage technology (IndexedDB→localStorage), corrected file paths to match architecture, added Testing section, changed npm to pnpm | Sarah (PO) |
| 2025-10-20 | 1.0 | Initial story created | Sarah (PO) |

## Dev Agent Record

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes List

_To be populated by dev agent_

### File List

_To be populated by dev agent_

## QA Results

_To be populated by QA agent_
