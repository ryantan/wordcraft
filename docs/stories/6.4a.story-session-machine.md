# Story 6.4a: Create StorySessionMachine

## Status

Draft

## Parent Story

[Story 6.4: Create Story Mode Flow](./6.4.integrate-story-checkpoints.md)

## Story

**As a** developer,
**I want** an XState machine to orchestrate story beat progression with support for multiple beat types (game, choice, narrative, checkpoint),
**so that** the story mode delivers a dynamic narrative experience with predictable, testable state management.

## Acceptance Criteria

1. `StorySessionMachine` is created in `machines/story/storySessionMachine.ts`
2. Machine accepts `wordList` as input parameter (not a runtime state)
3. Machine has core states: idle, showingIntro, processingBeat (with substates: showingNarrative, presentingChoice, playingGame, showingCheckpoint), finale
4. Machine handles all beat types: GameBeat, ChoiceBeat, NarrativeBeat, CheckpointBeat
5. LLM story generation stub created in `lib/story/story-generator.ts` (hardcoded templates, ready for OpenAI later)
6. Generated story includes: Stage 1 beats (one per word, pre-determined order), Stage 2 extra beats (for low-confidence words)
7. Stage 1: Words in story-coherent order (NOT random), each word appears once
8. Stage 2: Mastery phase uses extra beats for low-confidence words or fixed sequence
9. Machine spawns `StoryProgressMachine` as child actor for checkpoint tracking
10. Context includes: generatedStory, currentBeatIndex, wordStats, currentPhase, storyProgressActor
11. Machine persists state to sessionStorage
12. Comprehensive unit tests (40+ tests covering all beat types, transitions, guards, actions)
13. All types exported from machine module

## Tasks / Subtasks

- [ ] Create machine file structure
  - [ ] Create directory `machines/story/`
  - [ ] Create file `storySessionMachine.ts`
  - [ ] Create file `storySessionMachine.test.ts`
  - [ ] Create file `index.ts` for exports
  - [ ] Add types to `types/story.ts`

- [ ] Define beat type interfaces
  - [ ] `GameBeat` interface (type, id, narrative, word, gameType, stage)
  - [ ] `ChoiceBeat` interface (type, id, narrative, question, options)
  - [ ] `NarrativeBeat` interface (type, id, narrative)
  - [ ] `CheckpointBeat` interface (type, id, checkpointNumber, narrative, celebrationEmoji, title)
  - [ ] `StoryBeat` type union
  - [ ] Export all types

- [ ] Define machine context types
  - [ ] `StorySessionContext` interface
  - [ ] `GeneratedStory` interface (stage1Beats, stage2ExtraBeats, stage2FixedSequence)
  - [ ] `WordStats` interface (confidence, errors, hints, time, streak)
  - [ ] `StorySessionEvent` type union
  - [ ] Export all types

- [ ] Define machine states
  - [ ] `idle` - Initial state (auto-generates story, spawns actors, loads intro)
  - [ ] `showingIntro` - Display story introduction
  - [ ] `processingBeat` - Parent state with substates:
    - [ ] `showingNarrative` - Display narrative beat
    - [ ] `presentingChoice` - Display choice beat
    - [ ] `playingGame` - User plays game beat
    - [ ] `showingCheckpoint` - Display checkpoint celebration
  - [ ] `finale` - Story complete

- [ ] Define machine events
  - [ ] `START_STORY` - User clicked start from intro
  - [ ] `NARRATIVE_SEEN` - User clicked continue from narrative beat
  - [ ] `CHOICE_MADE` - User selected choice option (includes choice data)
  - [ ] `GAME_COMPLETED` - Game finished (includes result data)
  - [ ] `CONTINUE_STORY` - Continue from checkpoint
  - [ ] `SKIP_CHECKPOINT` - Skip checkpoint screen
  - [ ] `RESTART_STORY` - Start over

- [ ] Create LLM story generation stub (AC: 5, 6)
  - [ ] Create `lib/story/story-generator.ts`
  - [ ] Create `StoryGenerationInput` interface
  - [ ] Create `GeneratedStory` interface
  - [ ] Implement `generateStory()` stub function
  - [ ] Stub returns hardcoded template-based beats
  - [ ] Generate Stage 1 beats (one per word in story order)
  - [ ] Generate Stage 2 extra beats (placeholder Map)
  - [ ] Generate Stage 2 fixed sequence (fallback)
  - [ ] Include narrative, choice, game, and checkpoint beats
  - [ ] Document TODOs for future OpenAI integration
  - [ ] Export all interfaces and functions

- [ ] Implement word stats management (AC: 8)
  - [ ] Create `lib/story/word-stats.ts`
  - [ ] `initializeWordStats()` - Create initial stats for all words
  - [ ] `updateWordStats()` - Update after game completion
  - [ ] `calculateDifficultyScore()` - Multi-factor difficulty calculation
  - [ ] `getWordsNeedingPractice()` - Identify low-confidence words for Stage 2
  - [ ] Export all functions

- [ ] Implement machine actions
  - [ ] `generateStory` - Call LLM stub with wordList input
  - [ ] `spawnStoryProgressActor` - Create child actor
  - [ ] `initializeWordStats` - Create stats map for all words
  - [ ] `loadIntroContent` - Get intro from story content (Story 6.3)
  - [ ] `loadCurrentBeat` - Get beat at currentBeatIndex
  - [ ] `recordChoice` - Store user's choice selection
  - [ ] `updateWordStatsAfterGame` - Process game results
  - [ ] `advanceBeatIndex` - Move to next beat
  - [ ] `notifyStoryProgress` - Send GAME_COMPLETED to child
  - [ ] `loadCheckpointData` - Get checkpoint content from beat
  - [ ] `resetContinueDelay` - Reset continue button state
  - [ ] `enableContinueButton` - Allow user to continue (after 5s)
  - [ ] `acknowledgeCheckpoint` - Send CONTINUE_STORY to child
  - [ ] `skipCheckpoint` - Skip without notifying child
  - [ ] `loadFinaleContent` - Get finale content (Story 6.3)

- [ ] Implement machine guards
  - [ ] `isGameBeat` - Check if current beat is GameBeat
  - [ ] `isChoiceBeat` - Check if current beat is ChoiceBeat
  - [ ] `isNarrativeBeat` - Check if current beat is NarrativeBeat
  - [ ] `isCheckpointBeat` - Check if current beat is CheckpointBeat
  - [ ] `shouldShowFinale` - Check if all beats exhausted or all words mastered
  - [ ] `hasMoreBeats` - Check if beats remaining
  - [ ] `shouldTransitionToStage2` - Check if Stage 1 complete

- [ ] Implement state persistence
  - [ ] Save context to sessionStorage on state transitions
  - [ ] Load persisted state on machine initialization
  - [ ] Handle serialization of Maps and Sets
  - [ ] Handle Date serialization

- [ ] Create comprehensive tests
  - [ ] Test: Machine initializes with wordList input
  - [ ] Test: Story generation stub creates beats
  - [ ] Test: Intro → first beat transition
  - [ ] Test: Narrative beat flow (shows narrative → NARRATIVE_SEEN → next beat)
  - [ ] Test: Choice beat flow (presents choice → CHOICE_MADE → next beat)
  - [ ] Test: Game beat flow (plays game → GAME_COMPLETED → updates stats → next beat)
  - [ ] Test: Checkpoint beat flow (shows checkpoint → delayed continue → next beat)
  - [ ] Test: Beat type guards work correctly
  - [ ] Test: Stage 1 completes (all words practiced once in story order)
  - [ ] Test: Stage 2 uses extra beats for low-confidence words
  - [ ] Test: Stage 2 uses fixed sequence as fallback
  - [ ] Test: Checkpoint detection at correct beats
  - [ ] Test: Finale when all beats exhausted
  - [ ] Test: Finale when all words mastered early
  - [ ] Test: State persistence and restoration
  - [ ] Test: All guards return correct values
  - [ ] Test: All actions update context correctly
  - [ ] Run tests with `pnpm test`

## Dev Notes

### Machine Architecture

**Key Changes from Original Design:**
1. **No `selectingWordList` state** - wordList passed as machine input
2. **No `initializingStory` state** - initialization happens in `idle` state entry
3. **Beat types replace word selection** - LLM generates story with beat-level narrative
4. **Stage 1 NOT random** - Words in story-coherent order for narrative flow
5. **Hierarchical state structure** - `processingBeat` parent with beat-type substates

```typescript
// machines/story/storySessionMachine.ts
import { createMachine, assign, spawn } from 'xstate'
import { storyProgressMachine } from '@/lib/story/machines/storyProgressMachine'
import { generateStory } from '@/lib/story/story-generator'
import type { StorySessionContext, StorySessionEvent, StoryBeat } from '@/types/story'

export const storySessionMachine = createMachine({
  id: 'storySession',
  initial: 'idle',
  context: ({ input }) => ({
    // Input (provided when machine is created)
    wordList: input.wordList,      // WordList object
    storyTheme: input.theme || 'space',

    // Generated story structure
    generatedStory: null,          // GeneratedStory (stage1Beats, stage2ExtraBeats, stage2FixedSequence)
    currentBeatIndex: 0,
    currentBeat: null,             // Current StoryBeat

    // Phase tracking
    currentPhase: 'stage1',        // 'stage1' | 'stage2'

    // Word stats tracking
    wordStats: new Map<string, WordStats>(),
    userChoices: [],               // Record of choice beats

    // Story integration
    storyProgressActor: null,

    // Checkpoint data
    currentCheckpoint: null,
    canContinueStory: false,

    // Content
    introContent: null,
    finaleContent: null,

    // Session
    sessionStartTime: new Date(),
  }),

  states: {
    idle: {
      // Entry: Generate story, spawn actors, load intro
      entry: [
        'generateStory',           // Call LLM stub
        'spawnStoryProgressActor',
        'initializeWordStats',
        'loadIntroContent'
      ],
      always: 'showingIntro'
    },

    showingIntro: {
      on: {
        START_STORY: {
          target: 'processingBeat',
          actions: 'loadCurrentBeat'
        }
      }
    },

    processingBeat: {
      // Determine which substate based on beat type
      always: [
        { guard: 'isNarrativeBeat', target: '.showingNarrative' },
        { guard: 'isChoiceBeat', target: '.presentingChoice' },
        { guard: 'isGameBeat', target: '.playingGame' },
        { guard: 'isCheckpointBeat', target: '.showingCheckpoint' },
        { target: '#storySession.finale' } // No more beats
      ],

      states: {
        showingNarrative: {
          on: {
            NARRATIVE_SEEN: {
              actions: 'advanceBeatIndex',
              target: '#storySession.processingBeat' // Re-evaluate
            }
          }
        },

        presentingChoice: {
          on: {
            CHOICE_MADE: {
              actions: ['recordChoice', 'advanceBeatIndex'],
              target: '#storySession.processingBeat'
            }
          }
        },

        playingGame: {
          on: {
            GAME_COMPLETED: {
              actions: [
                'updateWordStatsAfterGame',
                'notifyStoryProgress',
                'advanceBeatIndex'
              ],
              target: '#storySession.processingBeat'
            }
          }
        },

        showingCheckpoint: {
          entry: ['resetContinueDelay'],
          on: {
            CONTINUE_STORY: {
              actions: ['acknowledgeCheckpoint', 'advanceBeatIndex'],
              target: '#storySession.processingBeat'
            },
            SKIP_CHECKPOINT: {
              actions: 'advanceBeatIndex',
              target: '#storySession.processingBeat'
            }
          },
          after: {
            5000: {
              actions: 'enableContinueButton'
            }
          }
        }
      }
    },

    finale: {
      entry: 'loadFinaleContent'
    }
  }
})
```

### Beat Type System

**All beats extend base interface:**
```typescript
interface BaseBeat {
  type: 'game' | 'choice' | 'narrative' | 'checkpoint'
  id: string
  narrative: string  // Displayed to user
}
```

**Beat Types:**

1. **GameBeat** - User plays spelling game
   ```typescript
   type GameBeat = BaseBeat & {
     type: 'game'
     word: string
     gameType: 'letterMatching' | 'wordBuilding' | 'multipleChoice'
     stage: 1 | 2  // Assessment or Mastery
   }
   ```

2. **ChoiceBeat** - User makes story decision
   ```typescript
   type ChoiceBeat = BaseBeat & {
     type: 'choice'
     question: string
     options: [string, string]  // Two choices
   }
   ```

3. **NarrativeBeat** - Pure story advancement
   ```typescript
   type NarrativeBeat = BaseBeat & {
     type: 'narrative'
     // Just narrative text, user clicks continue
   }
   ```

4. **CheckpointBeat** - Major milestone celebration
   ```typescript
   type CheckpointBeat = BaseBeat & {
     type: 'checkpoint'
     checkpointNumber: 1 | 2 | 3
     celebrationEmoji: string
     title: string
   }
   ```

### LLM Story Generation (Stub)

**Current Implementation:** Hardcoded template-based generation
**Future Implementation:** OpenAI API call to generate contextual story

```typescript
// lib/story/story-generator.ts

interface StoryGenerationInput {
  wordList: string[]
  theme: string
  targetBeats: number  // ~20 beats
}

interface GeneratedStory {
  stage1Beats: StoryBeat[]           // One per word (story order)
  stage2ExtraBeats: Map<string, StoryBeat[]>  // Extra beats per word
  stage2FixedSequence: StoryBeat[]   // Fallback sequence
}

// STUB: Returns template-based beats
export async function generateStory(input: StoryGenerationInput): Promise<GeneratedStory> {
  // TODO: Replace with OpenAI API call
  // Prompt: "Generate a {theme} adventure story with beats for these words: {wordList}"

  const stage1Beats = input.wordList.map((word, index) => ({
    type: 'game',
    id: `game-${word}-stage1`,
    narrative: `Your journey continues. Master the word "${word}"!`,
    word,
    gameType: 'letterMatching',
    stage: 1
  }))

  // Add checkpoints at beats 5, 10, 15
  // Add narrative/choice beats for variety

  return {
    stage1Beats,
    stage2ExtraBeats: new Map(),
    stage2FixedSequence: []
  }
}
```

### Stage 1 vs Stage 2

**Stage 1 (Assessment):**
- LLM generates coherent story with one beat per word
- Words in **story-relevant order** (NOT random)
- Example: "ROCKET" → "SPACE" → "ALIEN" → "PLANET" (follows narrative)
- Each word practiced exactly once
- Collects baseline stats: confidence, errors, time

**Stage 2 (Mastery):**
- System identifies low-confidence words from Stage 1
- Two approaches:
  1. Use `stage2ExtraBeats` - Pre-generated beats specific to each word
  2. Use `stage2FixedSequence` - Generic sequence for remaining practice
- Prioritizes difficult words
- Continues until mastery or beat limit reached

### Dependencies

**Required:**
- Story 6.2 (StoryProgressMachine) - Must be complete
- Story 6.3 (Narrative Content) - Provides intro/checkpoint/finale text
- XState 5.x - State machine library
- Existing confidence scoring algorithms

**Installation:**
No new dependencies - uses existing XState

### Testing Strategy

**Test Coverage Goals:**
- 100% state coverage (all states reachable)
- 100% transition coverage (all guards tested)
- 100% action coverage (all actions tested)
- Edge cases: empty word lists, all words mastered early, etc.

**Test Structure:**
```typescript
describe('StorySessionMachine', () => {
  describe('Initialization', () => {
    it('starts in idle state', () => {})
    it('loads persisted state if available', () => {})
  })

  describe('Word List Selection', () => {
    it('transitions to initializingStory on selection', () => {})
    it('stores word list in context', () => {})
  })

  describe('Story Initialization', () => {
    it('spawns StoryProgressMachine', () => {})
    it('generates 20 story beats', () => {})
    it('initializes word stats for all words', () => {})
    it('loads intro content for theme', () => {})
  })

  describe('Beat Progression', () => {
    it('selects random word in assessment phase', () => {})
    it('prioritizes difficult words in mastery phase', () => {})
    it('selects appropriate game mechanic', () => {})
    it('updates word stats on completion', () => {})
    it('increments beat counter', () => {})
  })

  describe('Checkpoint Detection', () => {
    it('shows checkpoint after 5 games', () => {})
    it('shows checkpoint after 10 games', () => {})
    it('shows checkpoint after 15 games', () => {})
    it('does not show checkpoint for other beat counts', () => {})
  })

  describe('Finale Conditions', () => {
    it('shows finale when all words mastered', () => {})
    it('shows finale when all beats complete', () => {})
  })

  describe('Persistence', () => {
    it('persists state to sessionStorage', () => {})
    it('restores state on page refresh', () => {})
    it('handles serialization of Maps and Sets', () => {})
  })
})
```

## Architectural Decision (2025-10-20)

**Decision:** Implement beat-based narrative system with LLM story generation (stub initially, OpenAI later).

**Key Changes from Original Design:**

1. **Remove runtime states for initialization**
   - No `selectingWordList` state - wordList is machine input
   - No `initializingStory` state - happens in `idle` entry actions
   - Cleaner separation: setup vs runtime

2. **Beat type system replaces word selection**
   - Four beat types: Game, Choice, Narrative, Checkpoint
   - Each beat has contextual narrative from LLM
   - State machine routes to correct substate based on beat type

3. **Stage 1 uses story-coherent word order**
   - NOT random selection
   - LLM determines word sequence for narrative flow
   - Example: "ROCKET" → "SPACE" → "ALIEN" (logical story progression)

4. **LLM stub for incremental implementation**
   - Start with hardcoded template-based generation
   - Interface designed for future OpenAI integration
   - Separate story: "Story 6.4a-LLM" will implement actual API calls

5. **Hierarchical state machine structure**
   - `processingBeat` parent state with beat-type substates
   - Guards determine routing: `isGameBeat`, `isChoiceBeat`, etc.
   - Cleaner than flat state machine with many transitions

**Rationale:**
- Beat-level narrative creates cohesive story experience
- LLM generation enables dynamic, contextual content
- Stub approach allows development to proceed without API keys
- Hierarchical states reduce complexity and improve testability

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 2.0 | Major architectural refinement: Beat type system, LLM stub, removed init states, hierarchical state machine | Sarah (PO) |
| 2025-10-20 | 1.0 | Initial substory created from parent Story 6.4 | James (Dev) |

## Dev Agent Record

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes List

_To be populated by dev agent_

### File List

_To be populated by dev agent_

## QA Results

_To be populated by QA agent_
