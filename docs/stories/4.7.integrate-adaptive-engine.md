# Story 4.7: Integrate Adaptive Engine with Game Session

## Status

Draft

## Story

**As a** child,
**I want** the game to feel personalized and smart about what I practice,
**so that** my time is spent on words I need help with, not ones I've mastered.

## Acceptance Criteria

1. `GameSessionMachine` queries `AdaptiveEngineMachine` for next word to practice
2. Words are selected based on confidence score and spaced repetition schedule
3. Mastered words (>80% confidence) appear less frequently in sessions
4. Struggling words (<60% confidence) are re-introduced 2-3 times per session
5. Session adapts mid-game based on real-time performance
6. Session ends when all words show adequate confidence or child opts to end
7. UI displays subtle confidence indicators (progress bars, colors) for parent view
8. System handles edge cases (all words mastered, all words struggling, single-word lists)

## Tasks / Subtasks

- [ ] Create integration between machines (AC: 1)
  - [ ] Update `GameSessionMachine` to spawn `AdaptiveEngineMachine` as a child actor
  - [ ] Create communication protocol between machines
  - [ ] Define events for querying adaptive engine:
    - `QUERY_NEXT_WORD` → returns word ID
    - `QUERY_GAME_TYPE` → returns game type
    - `QUERY_DIFFICULTY` → returns difficulty level
  - [ ] Update machine states to invoke adaptive engine

- [ ] Implement word selection integration (AC: 2)
  - [ ] Update `selectingWord` state in GameSessionMachine
  - [ ] Invoke adaptive engine's `getNextWord()` service
  - [ ] Service uses spaced repetition from Story 4.3
  - [ ] Service considers confidence scores from Story 4.1
  - [ ] Return word with lowest confidence or next due for review

- [ ] Implement frequency adjustment for mastered words (AC: 3)
  - [ ] Filter words by confidence level
  - [ ] Mastered words (>80%): Appear 1 time per session
  - [ ] Progressing words (60-80%): Appear 1-2 times per session
  - [ ] Struggling words (<60%): Appear 2-3 times per session
  - [ ] Track word appearances in session context

- [ ] Implement within-session re-introduction (AC: 4)
  - [ ] Track word performance within current session
  - [ ] If word failed (confidence drops), add back to session queue
  - [ ] Schedule struggling word to reappear after 2-3 other words
  - [ ] Maximum 3 attempts per word per session

- [ ] Implement mid-session adaptation (AC: 5)
  - [ ] After each game, send result to adaptive engine
  - [ ] Adaptive engine recalculates confidence
  - [ ] Update word prioritization based on new confidence
  - [ ] Adjust remaining session based on performance trends

- [ ] Define session completion criteria (AC: 6)
  - [ ] Session completes when:
    - All words attempted at least once AND
    - All words reach minimum confidence (40%+) OR
    - Child clicks "End Session" OR
    - Maximum session length reached (15 words)
  - [ ] Show session summary with progress

- [ ] Add confidence indicators to UI (AC: 7)
  - [ ] Create `ConfidenceIndicator` component
  - [ ] Display during session: small progress bar for current word
  - [ ] Color coding:
    - Red (<60%): Needs practice
    - Yellow (60-80%): Progressing
    - Green (>80%): Mastered
  - [ ] Show on word list page: confidence bars for each word
  - [ ] Subtle enough not to distract child, visible for parent

- [ ] Handle edge cases (AC: 8)
  - [ ] **All words mastered**: Congratulate and suggest new list
  - [ ] **All words struggling**: Don't overwhelm, limit to 5 words per session
  - [ ] **Single word list**: Allow practice but explain limitation
  - [ ] **Empty word list**: Show helpful error, redirect to create list
  - [ ] **No game results yet**: Start with balanced difficulty

- [ ] Update GameSessionMachine states
  - [ ] Modify `selectingWord` state to query adaptive engine
  - [ ] Modify `selectingGame` state to query for game type + difficulty
  - [ ] Add `checkingProgress` state after each game to update adaptive data
  - [ ] Update `sessionComplete` state to save all adaptive data

- [ ] Create integration tests (AC: 1-8)
  - [ ] Create test file `/__tests__/integration/adaptive-game-session.test.ts`
  - [ ] Test: Session prioritizes low confidence words
  - [ ] Test: Mastered words appear less frequently
  - [ ] Test: Struggling words reappear in same session
  - [ ] Test: Session adapts to mid-game performance
  - [ ] Test: Session completes with all criteria met
  - [ ] Test: Edge cases handled gracefully
  - [ ] Run tests with `npm run test:all`

## Dev Notes

### Architecture Context

**Machine Integration:**
[Source: docs/ui-architecture.md#XState Architecture]

```typescript
// GameSessionMachine spawns AdaptiveEngineMachine
export const gameSessionMachine = createMachine({
  id: 'gameSession',
  context: {
    wordListId: null,
    words: [],
    currentWord: null,
    currentGame: null,
    sessionResults: [],
    adaptiveEngine: null // Child actor reference
  },
  initial: 'idle',
  states: {
    idle: {
      on: {
        START_SESSION: {
          target: 'loading',
          actions: assign({
            adaptiveEngine: ({ spawn }) => spawn(adaptiveEngineMachine)
          })
        }
      }
    },
    selectingWord: {
      invoke: {
        src: 'selectNextWord',
        input: ({ context }) => ({
          adaptiveEngine: context.adaptiveEngine
        }),
        onDone: {
          target: 'selectingGame',
          actions: assign({
            currentWord: ({ event }) => event.output
          })
        }
      }
    }
    // ... other states
  }
})
```

**Communication Pattern:**
```typescript
// Service that queries adaptive engine
async function selectNextWord({ adaptiveEngine }) {
  // Send query event to adaptive engine
  adaptiveEngine.send({ type: 'QUERY_NEXT_WORD' })

  // Wait for response
  const snapshot = adaptiveEngine.getSnapshot()
  const nextWord = snapshot.context.nextWord

  return nextWord
}
```

**Session Flow with Adaptive Engine:**
```
START_SESSION
  ↓
LOADING (initialize adaptive engine)
  ↓
SELECTING_WORD (query adaptive engine → get word by confidence/schedule)
  ↓
SELECTING_GAME (query adaptive engine → get game by learning style)
  ↓
PLAYING_GAME (child plays)
  ↓
GAME_COMPLETE (send result to adaptive engine)
  ↓
CHECKING_PROGRESS (adaptive engine updates confidence)
  ↓
[More words?] → SELECTING_WORD
       OR
[Session complete] → SESSION_COMPLETE
```

**Confidence Indicator Component:**
[Source: docs/ui-architecture.md#Components]

```typescript
// components/game/ConfidenceIndicator.tsx
export function ConfidenceIndicator({ score }: { score: number }) {
  const level = score < 60 ? 'needs-work' : score < 80 ? 'progressing' : 'mastered'
  const color = level === 'needs-work' ? 'red' : level === 'progressing' ? 'yellow' : 'green'

  return (
    <div className="flex items-center gap-2">
      <div className="w-24 h-2 bg-gray-200 rounded-full overflow-hidden">
        <div
          className={`h-full bg-${color}-500 transition-all`}
          style={{ width: `${score}%` }}
        />
      </div>
      <span className="text-xs text-gray-600">{Math.round(score)}%</span>
    </div>
  )
}
```

**Word Selection Algorithm:**
```typescript
// Pseudocode for selecting next word
function getNextWord(
  words: Word[],
  confidenceScores: Map<string, number>,
  reviewSchedules: Map<string, ReviewSchedule>,
  sessionHistory: string[]
): string {
  // 1. Get words due for review (from spaced repetition)
  const dueWords = words.filter(w =>
    reviewSchedules.get(w.id).nextReviewDate <= new Date()
  )

  // 2. If no due words, get lowest confidence words
  const priorityWords = dueWords.length > 0
    ? dueWords
    : words.filter(w => confidenceScores.get(w.id) < 80)

  // 3. Exclude words already seen 3 times this session
  const availableWords = priorityWords.filter(w =>
    sessionHistory.filter(id => id === w.id).length < 3
  )

  // 4. Sort by confidence (lowest first)
  const sorted = availableWords.sort((a, b) =>
    confidenceScores.get(a.id) - confidenceScores.get(b.id)
  )

  // 5. Return lowest confidence word
  return sorted[0]?.id || words[0].id
}
```

### Dependencies

**Required:**
- Story 4.1 (Confidence Scoring) - MUST be complete
- Story 4.2 (Adaptive Engine Machine) - MUST be complete
- Story 4.3 (Spaced Repetition) - MUST be complete
- Story 4.4 (Learning Style Detection) - MUST be complete
- Story 4.5 (Adaptive Game Selection) - MUST be complete
- Story 4.6 (Dynamic Difficulty) - MUST be complete

**This story integrates ALL previous Epic 4 stories into the game flow.**

### Testing

[Source: docs/ui-architecture.md#Testing Strategy]

**Testing Framework:** Vitest + React Testing Library
**Test Location:** `/__tests__/integration/adaptive-game-session.test.ts`
**Coverage Target:** Integration test for full flow

**Integration Test Scenarios:**
```typescript
import { describe, it, expect } from 'vitest'
import { render, screen, waitFor } from '@testing-library/react'
import { userEvent } from '@testing-library/user-event'
import GamePage from '@/app/game/page'

describe('Adaptive Game Session Integration', () => {
  it('prioritizes low confidence words', async () => {
    // Setup word list with varied confidence
    const wordList = setupWordListWithConfidence([
      { word: 'easy', confidence: 90 },
      { word: 'hard', confidence: 30 },
      { word: 'medium', confidence: 60 }
    ])

    render(<GamePage wordListId={wordList.id} />)

    // First word should be 'hard' (lowest confidence)
    await waitFor(() => {
      expect(screen.getByText(/hard/i)).toBeInTheDocument()
    })
  })

  it('reintroduces struggling words in same session', async () => {
    const wordList = setupWordList(['cat', 'dog', 'bird'])

    render(<GamePage wordListId={wordList.id} />)

    // Play 'cat' and fail
    await playWord('cat', { isCorrect: false })

    // Play a few other words
    await playWord('dog', { isCorrect: true })

    // 'cat' should appear again
    await waitFor(() => {
      expect(screen.getByText(/cat/i)).toBeInTheDocument()
    })
  })

  it('completes session when criteria met', async () => {
    const wordList = setupWordList(['cat', 'dog'])

    render(<GamePage wordListId={wordList.id} />)

    // Play both words successfully
    await playWord('cat', { isCorrect: true })
    await playWord('dog', { isCorrect: true })

    // Session should complete
    await waitFor(() => {
      expect(screen.getByText(/session complete/i)).toBeInTheDocument()
    })
  })
})
```

**Run Tests:**
```bash
npm run test                  # Unit tests
npm run test:e2e              # E2E tests
npm run test:all              # All tests
```

### Technical Constraints

- XState v5 actor model for machine communication
- Real-time updates: Confidence recalculated after each game
- Performance: Word selection should execute in <20ms
- UX: Confidence indicators subtle, not distracting
- Data persistence: All adaptive data saved to IndexedDB

### Previous Story Insights

All Epic 4 stories (4.1-4.6) feed into this integration story:
- 4.1: Provides confidence scoring
- 4.2: Provides adaptive engine machine
- 4.3: Provides spaced repetition scheduling
- 4.4: Provides learning style profile
- 4.5: Provides game selection logic
- 4.6: Provides difficulty adjustment

This story brings them all together into a cohesive adaptive experience.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.0 | Initial story created | Sarah (PO) |

## Dev Agent Record

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes List

_To be populated by dev agent_

### File List

_To be populated by dev agent_

## QA Results

_To be populated by QA agent_
