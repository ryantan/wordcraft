# Story 6.4: Create Story Mode Flow (Parent Story)

## Status

In Progress

## Architectural Decision (2025-10-20)

**Decision:** Implement Story Mode as a separate flow from existing Practice Mode, rather than retrofitting existing game session management with XState.

**Rationale:**
- Keeps existing practice mode untouched (zero regression risk)
- Story Mode uses XState architecture (`StorySessionMachine` + `StoryProgressMachine`)
- Practice Mode continues using function-based approach (`session-manager.ts`)
- Both modes share same game components (LetterMatching, etc.)
- Separate routes: `/practice` (existing) vs `/story` (new)

**Implementation Breakdown:**
- Story 6.4a: Create StorySessionMachine
- Story 6.4b: Create Story Mode Page & UI Integration
- Story 6.4c: Story Intro & Finale Screens

## Story

**As a** child,
**I want** to experience a narrative story adventure while practicing spelling,
**so that** learning feels like playing through an exciting game with a beginning, middle, and end.

## Acceptance Criteria

1. ✅ **CheckpointScreen component exists** with animations, confetti, and delayed continue
2. Story Mode is a separate `/story` route (doesn't affect existing `/practice`)
3. `StorySessionMachine` orchestrates story beat progression
4. App automatically selects words and game mechanics (user doesn't choose)
5. Word selection uses two-phase approach: assessment → mastery
6. Checkpoints appear at appropriate story beats (5, 10, 15 games)
7. Story intro and finale screens frame the narrative experience
8. All story progress persists across sessions
9. Practice mode remains completely unchanged

## Completed Work

- [x] **CheckpointScreen Component** - Fully functional with animations, confetti, delayed continue
- [x] **Dependencies Installed** - react-confetti, framer-motion

## Substories

This parent story breaks down into focused implementation stories:

### [Story 6.4a: Create StorySessionMachine](./6.4a.story-session-machine.md)
**Status:** Not Started
**Scope:** Build core XState machine for story beat progression
- State machine with all states (idle, initializingStory, showingIntro, preparingBeat, playingBeat, beatCompleted, showingCheckpoint, finale)
- Word selection algorithms (two-phase: assessment → mastery)
- Beat progression logic
- Integration with StoryProgressMachine
- Comprehensive unit tests

### [Story 6.4b: Create Story Mode Page](./6.4b.story-mode-page.md)
**Status:** Not Started
**Scope:** New `/story` route with UI integration
- Create `app/story/page.tsx`
- Integrate StorySessionMachine with React
- Connect to existing game components
- Handle all machine states (intro, playing, checkpoint, finale)
- Responsive design

### [Story 6.4c: Story Intro & Finale Screens](./6.4c.intro-finale-screens.md)
**Status:** Not Started
**Scope:** Complete the story narrative experience
- StoryIntroScreen component
- StoryFinaleScreen component
- Integration with StorySessionMachine
- Animations and celebrations
- Component tests

## Original Tasks (Archived)
  - [ ] Update `/machines/game-session/gameSessionMachine.ts`
  - [ ] Import and spawn `StoryProgressMachine` as child actor
  - [ ] Setup bidirectional communication between machines
  - [ ] Add story context to GameSessionMachine context

- [ ] Add story checkpoint detection (AC: 2)
  - [ ] Listen to `GAME_COMPLETED` events in GameSessionMachine
  - [ ] After each game completion, send event to StoryProgressMachine
  - [ ] StoryProgressMachine determines if checkpoint reached
  - [ ] Transition to checkpoint state when triggered

- [ ] Create checkpoint state in GameSessionMachine (AC: 1, 2)
  - [ ] Add new state: `showingCheckpoint`
  - [ ] State transitions from `completed` → `showingCheckpoint` → `selectingGame`
  - [ ] Context includes current checkpoint info
  - [ ] Example state structure:
    ```typescript
    states: {
      // ... existing states
      completed: {
        always: [
          {
            guard: 'shouldShowCheckpoint',
            target: 'showingCheckpoint'
          },
          { target: 'selectingGame' }
        ]
      },
      showingCheckpoint: {
        entry: 'loadCheckpointData',
        on: {
          CONTINUE_STORY: 'selectingGame',
          SKIP_CHECKPOINT: 'selectingGame'
        },
        after: {
          5000: {
            // Auto-enable continue button after 5 seconds
            actions: 'enableContinueButton'
          }
        }
      }
    }
    ```

- [ ] Implement checkpoint detection guard (AC: 2)
  - [ ] Create `shouldShowCheckpoint` guard:
    ```typescript
    guards: {
      shouldShowCheckpoint: ({ context }) => {
        const { storyProgress } = context
        const snapshot = storyProgress.getSnapshot()

        // Check if we're at a checkpoint state
        return snapshot.matches('checkpoint1') ||
               snapshot.matches('checkpoint2') ||
               snapshot.matches('checkpoint3') ||
               snapshot.matches('finale')
      }
    }
    ```

- [ ] Create CheckpointScreen component (AC: 3, 7)
  - [ ] Create file `/components/story/CheckpointScreen.tsx`
  - [ ] Component props:
    ```typescript
    interface CheckpointScreenProps {
      checkpoint: StoryCheckpoint
      backgroundImage: string
      characterImage: string
      onContinue: () => void
      onSkip: () => void
      canContinue: boolean
    }
    ```
  - [ ] Layout structure:
    - Full-screen overlay
    - Background image (environment)
    - Character sprite (animated)
    - Narrative text box
    - Continue/Skip buttons

- [ ] Implement checkpoint visuals (AC: 3, 7)
  - [ ] Display background image from story assets
  - [ ] Display character sprite in foreground
  - [ ] Style narrative text box:
    - Semi-transparent background
    - Large, readable text
    - Centered or bottom-third placement
  - [ ] Distinctive visual theme (different from game screens)
  - [ ] Use story theme colors and styling

- [ ] Add checkpoint animations (AC: 4)
  - [ ] Character entrance animation:
    - Slide in from side
    - Bounce or celebrate motion
    - Use Framer Motion
  - [ ] Background animation:
    - Fade in or zoom effect
    - Subtle parallax if appropriate
  - [ ] Celebration effects:
    - Confetti particles (react-confetti)
    - Sparkles or stars
    - Success sound effect (if audio implemented)
  - [ ] Text animation:
    - Fade in with slight delay
    - Typewriter effect (optional)

- [ ] Implement continue button delay (AC: 5)
  - [ ] Button starts disabled
  - [ ] Use XState `after` transition to enable after 3-5 seconds
  - [ ] Visual indicator: button grays out → animates to active
  - [ ] "Skip" option available immediately
  - [ ] Example implementation:
    ```typescript
    const [canContinue, setCanContinue] = useState(false)

    useEffect(() => {
      const timer = setTimeout(() => setCanContinue(true), 5000)
      return () => clearTimeout(timer)
    }, [])
    ```

- [ ] Create smooth transitions (AC: 6)
  - [ ] Fade transition from game completion to checkpoint
  - [ ] Delay checkpoint appearance by 500ms after game completes
  - [ ] Smooth transition back to game selection
  - [ ] Prevent jarring cuts between states
  - [ ] Use Framer Motion AnimatePresence

- [ ] Integrate checkpoint content (AC: 3)
  - [ ] Load narrative from `/lib/story/content.ts`
  - [ ] Select correct checkpoint based on progress
  - [ ] Display checkpoint title and narrative
  - [ ] Show celebration emoji/icon
  - [ ] Pass word count for template interpolation

- [ ] Implement checkpoint persistence (AC: 8)
  - [ ] StoryProgressMachine already persists to IndexedDB
  - [ ] Verify checkpoint unlocks are saved
  - [ ] Test checkpoint state restoration on page reload
  - [ ] Ensure checkpoints don't repeat inappropriately

- [ ] Add skip functionality (AC: 5)
  - [ ] "Skip" button available immediately
  - [ ] Clearly labeled but not prominent (don't encourage skipping)
  - [ ] Sends `SKIP_CHECKPOINT` event to machine
  - [ ] Transitions to next state without delay
  - [ ] Track skips in analytics (optional)

- [ ] Handle edge cases
  - [ ] First session: show story intro before first game
  - [ ] Resuming session: don't re-show already-seen checkpoints
  - [ ] Final checkpoint (finale): different handling
  - [ ] User closes browser during checkpoint: resume correctly
  - [ ] Multiple word lists: track story per list or globally

- [ ] Create React hook for checkpoint state
  - [ ] Create `/hooks/useCheckpointScreen.ts`:
    ```typescript
    export function useCheckpointScreen() {
      const [state, send] = useActor(gameSessionMachine)

      const isShowingCheckpoint = state.matches('showingCheckpoint')
      const checkpointData = state.context.currentCheckpoint
      const canContinue = state.context.canContinueStory

      return {
        isShowingCheckpoint,
        checkpointData,
        canContinue,
        continueStory: () => send({ type: 'CONTINUE_STORY' }),
        skipCheckpoint: () => send({ type: 'SKIP_CHECKPOINT' })
      }
    }
    ```

- [ ] Update game session UI (AC: 7)
  - [ ] Add checkpoint screen to game session flow
  - [ ] Conditional rendering based on machine state
  - [ ] Example:
    ```tsx
    {state.matches('showingCheckpoint') && (
      <CheckpointScreen
        checkpoint={state.context.currentCheckpoint}
        backgroundImage={getCheckpointBackground(state.context.checkpoint)}
        characterImage={getCharacterSprite('celebrating')}
        onContinue={() => send({ type: 'CONTINUE_STORY' })}
        onSkip={() => send({ type: 'SKIP_CHECKPOINT' })}
        canContinue={state.context.canContinueStory}
      />
    )}
    ```

- [ ] Create component tests
  - [ ] Create test file `/components/story/CheckpointScreen.test.tsx`
  - [ ] Test: Checkpoint renders with all elements
  - [ ] Test: Continue button disabled initially
  - [ ] Test: Continue enabled after delay
  - [ ] Test: Skip button works immediately
  - [ ] Test: Animations render without errors
  - [ ] Run tests with `npm run test`

- [ ] Create integration tests
  - [ ] Create test file `/__tests__/integration/story-checkpoint-flow.test.ts`
  - [ ] Test: Checkpoint appears after N games
  - [ ] Test: GameSessionMachine transitions correctly
  - [ ] Test: StoryProgressMachine updates on checkpoint
  - [ ] Test: Checkpoint data persists across sessions
  - [ ] Test: Can skip checkpoint
  - [ ] Test: Continue advances to next game
  - [ ] Run tests with `npm run test`

## Dev Notes

### Architecture Context

**Machine Integration Pattern:**
[Source: docs/ui-architecture.md#StoryProgressMachine Integration]

```typescript
// machines/game-session/gameSessionMachine.ts
import { createMachine, assign, spawn } from 'xstate'
import { storyProgressMachine } from '../story-progress/storyProgressMachine'

export const gameSessionMachine = createMachine({
  id: 'gameSession',
  context: {
    storyProgressActor: null,
    currentCheckpoint: null,
    canContinueStory: false
  },
  states: {
    initializing: {
      entry: assign({
        storyProgressActor: ({ spawn }) => spawn(storyProgressMachine)
      }),
      always: 'selectingGame'
    },
    playing: {
      // ... game logic
    },
    completed: {
      entry: 'notifyStoryProgress',
      always: [
        {
          guard: 'shouldShowCheckpoint',
          target: 'showingCheckpoint',
          actions: 'loadCheckpointData'
        },
        { target: 'selectingGame' }
      ]
    },
    showingCheckpoint: {
      on: {
        CONTINUE_STORY: {
          target: 'selectingGame',
          actions: 'acknowledgeCheckpoint'
        },
        SKIP_CHECKPOINT: 'selectingGame'
      },
      after: {
        5000: {
          actions: assign({ canContinueStory: true })
        }
      }
    }
  }
}, {
  actions: {
    notifyStoryProgress: ({ context }) => {
      context.storyProgressActor?.send({ type: 'GAME_COMPLETED' })
    },
    loadCheckpointData: assign(({ context }) => {
      const snapshot = context.storyProgressActor?.getSnapshot()
      const checkpointNumber = snapshot?.context.currentCheckpoint

      return {
        currentCheckpoint: getStoryContent('space').checkpoints[checkpointNumber - 1],
        canContinueStory: false
      }
    }),
    acknowledgeCheckpoint: ({ context }) => {
      context.storyProgressActor?.send({ type: 'CONTINUE_STORY' })
    }
  },
  guards: {
    shouldShowCheckpoint: ({ context }) => {
      const snapshot = context.storyProgressActor?.getSnapshot()
      return snapshot?.matches('checkpoint1') ||
             snapshot?.matches('checkpoint2') ||
             snapshot?.matches('checkpoint3') ||
             snapshot?.matches('finale')
    }
  }
})
```

**CheckpointScreen Component:**
```typescript
'use client'

import { motion, AnimatePresence } from 'framer-motion'
import { useEffect, useState } from 'react'
import Confetti from 'react-confetti'
import { StoryCheckpoint } from '@/lib/story/content'

interface CheckpointScreenProps {
  checkpoint: StoryCheckpoint
  backgroundImage: string
  characterImage: string
  onContinue: () => void
  onSkip: () => void
  canContinue: boolean
}

export function CheckpointScreen({
  checkpoint,
  backgroundImage,
  characterImage,
  onContinue,
  onSkip,
  canContinue
}: CheckpointScreenProps) {
  const [showConfetti, setShowConfetti] = useState(true)

  useEffect(() => {
    const timer = setTimeout(() => setShowConfetti(false), 5000)
    return () => clearTimeout(timer)
  }, [])

  return (
    <motion.div
      className="fixed inset-0 z-50 flex items-center justify-center"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      transition={{ duration: 0.5 }}
    >
      {/* Background */}
      <div
        className="absolute inset-0 bg-cover bg-center"
        style={{ backgroundImage: `url(${backgroundImage})` }}
      />

      {/* Confetti */}
      {showConfetti && <Confetti recycle={false} numberOfPieces={200} />}

      {/* Character */}
      <motion.img
        src={characterImage}
        alt="Character celebrating"
        className="absolute bottom-10 left-10 w-64 h-64"
        initial={{ x: -300, opacity: 0 }}
        animate={{ x: 0, opacity: 1 }}
        transition={{ type: 'spring', delay: 0.3 }}
      />

      {/* Narrative Box */}
      <motion.div
        className="relative z-10 max-w-2xl mx-auto p-8 bg-white/90 rounded-2xl shadow-2xl"
        initial={{ y: 50, opacity: 0 }}
        animate={{ y: 0, opacity: 1 }}
        transition={{ delay: 0.5 }}
      >
        <div className="text-center">
          <div className="text-6xl mb-4">{checkpoint.celebrationEmoji}</div>
          <h2 className="text-3xl font-bold mb-4 text-purple-700">
            {checkpoint.title}
          </h2>
          <p className="text-xl text-gray-700 mb-6 leading-relaxed">
            {checkpoint.narrative}
          </p>

          <div className="flex gap-4 justify-center">
            <button
              onClick={onSkip}
              className="px-6 py-2 text-gray-600 hover:text-gray-800 transition-colors"
            >
              Skip
            </button>
            <motion.button
              onClick={onContinue}
              disabled={!canContinue}
              className={`px-8 py-3 rounded-lg font-bold text-white transition-all ${
                canContinue
                  ? 'bg-green-500 hover:bg-green-600 scale-100'
                  : 'bg-gray-400 cursor-not-allowed scale-95'
              }`}
              animate={canContinue ? { scale: [1, 1.05, 1] } : {}}
              transition={{ repeat: Infinity, duration: 1.5 }}
            >
              Continue Adventure
            </motion.button>
          </div>
        </div>
      </motion.div>
    </motion.div>
  )
}
```

**Transition Timing:**
```
Game Completes
     ↓
  500ms delay
     ↓
Checkpoint Screen Fades In (500ms)
     ↓
Character Slides In (300ms after fade starts)
     ↓
Narrative Box Appears (500ms after fade starts)
     ↓
Confetti Plays (5 seconds)
     ↓
Continue Button Enables (5 seconds)
     ↓
User Clicks Continue
     ↓
Fade Out (500ms)
     ↓
Next Game Loads
```

### Dependencies

**Required:**
- Story 6.1 (Story Theme Assets) - Needs background and character images
- Story 6.2 (Story Progress Machine) - Machine must exist to integrate
- Story 6.3 (Narrative Content) - Needs narrative text to display
- `react-confetti` - Celebration effects
- `framer-motion` - Animations

**Installation:**
```bash
npm install react-confetti framer-motion
```

**Enables:**
- Story 6.5 (Intro/Finale Screens) - Similar pattern
- Story 6.6 (Story Visual Elements) - Uses same assets

### Testing

**Testing Framework:** Vitest + React Testing Library
**Test Locations:**
- `/components/story/CheckpointScreen.test.tsx` - Component tests
- `/__tests__/integration/story-checkpoint-flow.test.ts` - Integration tests

**Component Test Scenarios:**
```typescript
import { describe, it, expect, vi } from 'vitest'
import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import { CheckpointScreen } from './CheckpointScreen'

describe('CheckpointScreen Component', () => {
  const mockCheckpoint = {
    id: 'checkpoint1',
    title: 'Moon Landing',
    narrative: 'Amazing work! You\'ve landed on the Moon.',
    celebrationEmoji: '🌙'
  }

  it('renders checkpoint content', () => {
    render(
      <CheckpointScreen
        checkpoint={mockCheckpoint}
        backgroundImage="/test-bg.png"
        characterImage="/test-char.png"
        onContinue={vi.fn()}
        onSkip={vi.fn()}
        canContinue={false}
      />
    )

    expect(screen.getByText('Moon Landing')).toBeInTheDocument()
    expect(screen.getByText(/Amazing work!/)).toBeInTheDocument()
  })

  it('continue button disabled initially', () => {
    render(
      <CheckpointScreen
        checkpoint={mockCheckpoint}
        backgroundImage="/test-bg.png"
        characterImage="/test-char.png"
        onContinue={vi.fn()}
        onSkip={vi.fn()}
        canContinue={false}
      />
    )

    const continueBtn = screen.getByText('Continue Adventure')
    expect(continueBtn).toBeDisabled()
  })

  it('continue button enabled when canContinue is true', () => {
    render(
      <CheckpointScreen
        checkpoint={mockCheckpoint}
        backgroundImage="/test-bg.png"
        characterImage="/test-char.png"
        onContinue={vi.fn()}
        onSkip={vi.fn()}
        canContinue={true}
      />
    )

    const continueBtn = screen.getByText('Continue Adventure')
    expect(continueBtn).not.toBeDisabled()
  })

  it('calls onSkip when skip button clicked', async () => {
    const mockOnSkip = vi.fn()
    render(
      <CheckpointScreen
        checkpoint={mockCheckpoint}
        backgroundImage="/test-bg.png"
        characterImage="/test-char.png"
        onContinue={vi.fn()}
        onSkip={mockOnSkip}
        canContinue={false}
      />
    )

    await userEvent.click(screen.getByText('Skip'))
    expect(mockOnSkip).toHaveBeenCalled()
  })

  it('calls onContinue when continue button clicked', async () => {
    const mockOnContinue = vi.fn()
    render(
      <CheckpointScreen
        checkpoint={mockCheckpoint}
        backgroundImage="/test-bg.png"
        characterImage="/test-char.png"
        onContinue={mockOnContinue}
        onSkip={vi.fn()}
        canContinue={true}
      />
    )

    await userEvent.click(screen.getByText('Continue Adventure'))
    expect(mockOnContinue).toHaveBeenCalled()
  })
})
```

**Integration Test Scenarios:**
```typescript
import { describe, it, expect } from 'vitest'
import { createActor } from 'xstate'
import { gameSessionMachine } from '@/machines/game-session/gameSessionMachine'

describe('Story Checkpoint Integration', () => {
  it('shows checkpoint after 5 games completed', () => {
    const actor = createActor(gameSessionMachine)
    actor.start()

    // Complete 5 games
    for (let i = 0; i < 5; i++) {
      actor.send({ type: 'GAME_COMPLETED', result: { isCorrect: true } })
    }

    expect(actor.getSnapshot().matches('showingCheckpoint')).toBe(true)
  })

  it('transitions to next game after continue', () => {
    const actor = createActor(gameSessionMachine)
    actor.start()

    // Get to checkpoint
    for (let i = 0; i < 5; i++) {
      actor.send({ type: 'GAME_COMPLETED', result: { isCorrect: true } })
    }

    expect(actor.getSnapshot().matches('showingCheckpoint')).toBe(true)

    // Continue story
    actor.send({ type: 'CONTINUE_STORY' })

    expect(actor.getSnapshot().matches('selectingGame')).toBe(true)
  })

  it('can skip checkpoint', () => {
    const actor = createActor(gameSessionMachine)
    actor.start()

    // Get to checkpoint
    for (let i = 0; i < 5; i++) {
      actor.send({ type: 'GAME_COMPLETED', result: { isCorrect: true } })
    }

    // Skip checkpoint
    actor.send({ type: 'SKIP_CHECKPOINT' })

    expect(actor.getSnapshot().matches('selectingGame')).toBe(true)
  })
})
```

**Run Tests:**
```bash
npm run test
```

### Technical Constraints

- Checkpoint animations: Smooth, 60fps
- Image loading: Preload assets to prevent flicker
- Continue delay: 3-5 seconds (tunable)
- Accessibility: Keyboard navigation, screen reader support
- Mobile: Touch-friendly, responsive layout
- Performance: No lag on transition to checkpoint

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 2.0 | Architectural decision: Story Mode as separate flow. Converted to parent story with 3 substories (6.4a, 6.4b, 6.4c). CheckpointScreen component completed. | James (Dev) |
| 2025-10-20 | 1.0 | Initial story created | Sarah (PO) |

## Dev Agent Record

### Agent Model Used

claude-sonnet-4-5-20250929

### Architectural Decision

**Date:** 2025-10-20

**Decision:** Implement Story Mode as separate `/story` route with StorySessionMachine, keep existing Practice Mode (`/practice`) untouched.

**Rationale:**
- Zero regression risk to existing functionality
- Clean separation of concerns
- Story Mode gets full XState architecture benefits
- Both modes share game components (no duplication)
- Can develop and test story mode independently
- Easier to maintain and extend

**Key Changes from Original Design:**
- **Original:** Retrofit existing game flow with GameSessionMachine
- **New:** Create separate StorySessionMachine for `/story` route
- **Original:** User selects games
- **New:** App selects word + game mechanic automatically
- **Original:** Simple session tracking
- **New:** Story beats (15-20) with two-phase word selection (assessment → mastery)

### Completion Notes List

**Completed Work:**
- ✅ CheckpointScreen component with animations, confetti, delayed continue
- ✅ Dependencies installed (react-confetti, framer-motion)
- ✅ Story restructured into 3 focused substories
- ✅ Architectural diagrams created for StorySessionMachine
- ✅ Word selection algorithm designed (two-phase approach)

**Remaining Work (see substories):**
- Story 6.4a: StorySessionMachine implementation
- Story 6.4b: Story Mode page and UI integration
- Story 6.4c: Intro & Finale screens

### File List

**Created:**
- `components/story/CheckpointScreen.tsx` - Full checkpoint celebration UI

**Modified:**
- `package.json` - Added react-confetti, framer-motion
- `pnpm-lock.yaml` - Dependency updates

## QA Results

_To be populated by QA agent_
