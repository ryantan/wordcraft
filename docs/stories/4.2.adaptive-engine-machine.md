# Story 4.2: Create Adaptive Engine State Machine

## Status

Draft

## Story

**As a** developer,
**I want** to build an XState machine that manages word prioritization, learning style detection, and game selection,
**so that** the adaptive logic is centralized and testable.

## Acceptance Criteria

1. `AdaptiveEngineMachine` is created in `/machines/adaptive-engine/adaptiveEngineMachine.ts`
2. Machine manages context: word confidence scores, learning style profile, session metrics
3. Machine provides services: `prioritizeWords()`, `selectGame()`, `updateConfidence()`, `detectLearningStyle()`
4. Machine updates confidence scores after each game result
5. Machine is visualizable in XState Inspector
6. Machine can be queried by `GameSessionMachine` for word/game selection
7. Unit tests verify adaptive logic and state transitions
8. Machine persists adaptive data to IndexedDB

## Tasks / Subtasks

- [ ] Create adaptive engine machine module (AC: 1, 2)
  - [ ] Create directory `/machines/adaptive-engine/`
  - [ ] Create file `adaptiveEngineMachine.ts`
  - [ ] Define machine states: `idle`, `analyzing`, `updatingConfidence`, `detectingStyle`, `prioritizing`, `ready`
  - [ ] Define machine context with TypeScript types:
    - `wordConfidences: Map<string, ConfidenceScore>`
    - `learningStyle: LearningStyleProfile | null`
    - `sessionMetrics: SessionMetrics`
  - [ ] Define machine events for triggering updates and queries
  - [ ] Implement state transitions with guards and actions

- [ ] Implement core services (AC: 3, 4)
  - [ ] Create `updateConfidence` service that integrates confidence-scoring algorithm from Story 4.1
  - [ ] Create `prioritizeWords` service that ranks words by confidence (low to high)
  - [ ] Create placeholder `selectGame` service (will be enhanced in Story 4.5)
  - [ ] Create placeholder `detectLearningStyle` service (will be implemented in Story 4.4)
  - [ ] Add actions to update context after each service completes

- [ ] Integrate with confidence scoring algorithm (AC: 4)
  - [ ] Import `calculateConfidence` from Story 4.1
  - [ ] Update machine context when new game results are received
  - [ ] Recalculate confidence scores for affected words
  - [ ] Store updated confidence in machine context

- [ ] Create machine types file (AC: 2)
  - [ ] Create `/machines/adaptive-engine/types.ts`
  - [ ] Define `AdaptiveEngineContext` type
  - [ ] Define `AdaptiveEngineEvent` union type
  - [ ] Define `LearningStyleProfile` type (detailed in Story 4.4)
  - [ ] Define `SessionMetrics` type

- [ ] Implement IndexedDB persistence (AC: 8)
  - [ ] Create `/lib/storage/adaptive-data-storage.ts`
  - [ ] Implement functions: `saveAdaptiveData()`, `loadAdaptiveData()`
  - [ ] Save confidence scores to IndexedDB when updated
  - [ ] Load confidence scores when machine initializes
  - [ ] Handle storage errors gracefully

- [ ] Enable XState Inspector integration (AC: 5)
  - [ ] Configure machine to work with XState Inspector in development
  - [ ] Add machine ID: `'adaptiveEngine'`
  - [ ] Verify machine is visible in Inspector UI
  - [ ] Test state transitions and context updates in Inspector

- [ ] Create integration points for GameSessionMachine (AC: 6)
  - [ ] Export hook `useAdaptiveEngine()` in `/hooks/useAdaptiveEngine.ts`
  - [ ] Provide methods for querying: `getNextWord()`, `getRecommendedGame()`
  - [ ] Ensure machine can respond to queries without re-initializing

- [ ] Write comprehensive unit tests (AC: 7)
  - [ ] Create test file `/machines/adaptive-engine/adaptiveEngineMachine.test.ts`
  - [ ] Test: Machine initializes in `idle` state
  - [ ] Test: Transitions to `analyzing` when receiving game result
  - [ ] Test: Updates confidence context correctly
  - [ ] Test: Prioritizes words by confidence (lowest first)
  - [ ] Test: Persists data to IndexedDB after updates
  - [ ] Test: Loads persisted data on initialization
  - [ ] Run tests with `npm run test`

## Dev Notes

### Architecture Context

**File Structure:**
[Source: docs/ui-architecture.md#Project Structure]
```
machines/
├── adaptive-engine/
│   ├── adaptiveEngineMachine.ts       # Main machine definition
│   ├── adaptiveEngineMachine.test.ts  # Unit tests
│   ├── confidence.ts                  # Confidence scoring logic (from 4.1)
│   ├── learning-style.ts              # Learning style detection (4.4)
│   ├── types.ts                       # Machine-specific types
│   └── index.ts                       # Exports
```

**XState Machine Pattern:**
[Source: docs/ui-architecture.md#AdaptiveEngineMachine]

**States:**
```
idle → analyzing → updatingConfidence → detectingStyle → prioritizing → ready
```

**Context Structure:**
```typescript
interface AdaptiveEngineContext {
  wordConfidences: Map<string, ConfidenceScore>
  learningStyle: LearningStyleProfile | null
  sessionMetrics: SessionMetrics
  lastUpdated: Date
}

interface LearningStyleProfile {
  visual: number      // 0-1 score
  auditory: number    // 0-1 score
  kinesthetic: number // 0-1 score
  confidence: number  // How confident we are in this profile
}

interface SessionMetrics {
  totalGamesPlayed: number
  wordsAttempted: number
  averageAccuracy: number
}
```

**Event Types:**
```typescript
type AdaptiveEngineEvent =
  | { type: 'GAME_RESULT'; word: string; result: GameResult }
  | { type: 'UPDATE_CONFIDENCE'; word: string; delta: number }
  | { type: 'QUERY_NEXT_WORD' }
  | { type: 'QUERY_GAME'; word: string }
  | { type: 'RESET' }
```

**Machine Definition Example:**
[Source: docs/ui-architecture.md#AdaptiveEngineMachine]
```typescript
export const adaptiveEngineMachine = createMachine({
  id: 'adaptiveEngine',
  initial: 'idle',
  context: {
    wordConfidences: new Map(),
    learningStyle: null,
    sessionMetrics: {
      totalGamesPlayed: 0,
      wordsAttempted: 0,
      averageAccuracy: 0
    },
    lastUpdated: new Date()
  },
  states: {
    idle: {
      on: {
        GAME_RESULT: 'analyzing'
      }
    },
    analyzing: {
      always: 'updatingConfidence'
    },
    updatingConfidence: {
      invoke: {
        src: 'calculateConfidence',
        onDone: {
          target: 'detectingStyle',
          actions: assign({
            wordConfidences: ({ event }) => event.output
          })
        }
      }
    },
    detectingStyle: {
      // Will be implemented in Story 4.4
      always: 'prioritizing'
    },
    prioritizing: {
      invoke: {
        src: 'prioritizeWords',
        onDone: {
          target: 'ready'
        }
      }
    },
    ready: {
      on: {
        GAME_RESULT: 'analyzing',
        QUERY_NEXT_WORD: { actions: 'provideNextWord' },
        QUERY_GAME: { actions: 'provideGameRecommendation' }
      }
    }
  }
})
```

**Integration with Confidence Scoring:**
[Source: Story 4.1]
- Import `calculateConfidence` from `/lib/algorithms/confidence-scoring.ts`
- Use it within the `updateConfidence` service
- Store results in `wordConfidences` Map in context

**IndexedDB Storage:**
[Source: docs/ui-architecture.md#Data Persistence]
- Use IndexedDB for structured adaptive data (confidence scores, learning profile)
- Storage location: `adaptive_engine_data` object store
- Save after each confidence update
- Load on machine initialization

### Dependencies

**Required:**
- Story 4.1 (Confidence Scoring Algorithm) - MUST be complete
  - Provides `calculateConfidence()` function

**Future Integration:**
- Story 4.3 (Spaced Repetition) - Will use `prioritizeWords()` service
- Story 4.4 (Learning Style Detection) - Will implement `detectingStyle` state
- Story 4.5 (Adaptive Game Selection) - Will implement `selectGame()` service

### Testing

[Source: docs/ui-architecture.md#Testing Strategy]

**Testing Framework:** Vitest + XState testing utilities
**Test Location:** `/machines/adaptive-engine/adaptiveEngineMachine.test.ts`
**Coverage Target:** 70%+ for machine logic

**XState Machine Testing Pattern:**
```typescript
import { describe, it, expect } from 'vitest'
import { createActor } from 'xstate'
import { adaptiveEngineMachine } from './adaptiveEngineMachine'

describe('AdaptiveEngineMachine', () => {
  it('initializes in idle state', () => {
    const actor = createActor(adaptiveEngineMachine)
    actor.start()
    expect(actor.getSnapshot().matches('idle')).toBe(true)
  })

  it('transitions to analyzing on GAME_RESULT event', () => {
    const actor = createActor(adaptiveEngineMachine)
    actor.start()

    actor.send({
      type: 'GAME_RESULT',
      word: 'cat',
      result: { isCorrect: true, attempts: 1 }
    })

    expect(actor.getSnapshot().matches('analyzing')).toBe(true)
  })

  it('updates confidence scores in context', async () => {
    const actor = createActor(adaptiveEngineMachine)
    actor.start()

    actor.send({
      type: 'GAME_RESULT',
      word: 'cat',
      result: { isCorrect: true, attempts: 1 }
    })

    await waitFor(actor, (state) => state.matches('ready'))

    const context = actor.getSnapshot().context
    expect(context.wordConfidences.has('cat')).toBe(true)
  })
})
```

**Run Tests:**
```bash
npm run test                  # Run in watch mode
npm run test:coverage         # With coverage report
```

### XState Inspector Setup

[Source: docs/ui-architecture.md#XState Inspector]

Enable in development only:
```typescript
// In development mode, enable Inspector
if (process.env.NODE_ENV === 'development') {
  import('@xstate/inspect').then(({ inspect }) => {
    inspect({
      iframe: false // Use browser extension
    })
  })
}
```

### Technical Constraints

- XState v5 API must be used (not v4)
- TypeScript strict mode for all types
- Machine must be pure (no direct DOM or localStorage access in machine logic)
- Services handle side effects (IndexedDB, calculations)
- Context updates via `assign()` actions only

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.0 | Initial story created | Sarah (PO) |

## Dev Agent Record

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes List

_To be populated by dev agent_

### File List

_To be populated by dev agent_

## QA Results

_To be populated by QA agent_
