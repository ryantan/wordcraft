# Story 4.6: Implement Dynamic Difficulty Adjustment

## Status

Draft

## Story

**As a** child,
**I want** games to get slightly harder when I'm doing well and easier when I'm struggling,
**so that** practice stays appropriately challenging.

## Acceptance Criteria

1. Each game component accepts a `difficulty: 'easy' | 'medium' | 'hard'` prop
2. Difficulty affects game parameters: time limits, hint availability, complexity
3. `AdaptiveEngineMachine` determines difficulty based on recent performance (last 3-5 attempts)
4. Consecutive correct answers → increase difficulty; consecutive errors → decrease difficulty
5. Difficulty adjustments are gradual (don't jump from easy to hard immediately)
6. System balances challenge with confidence-building (70-80% success rate target)
7. Games implement difficulty variations (e.g., more/fewer missing letters, tighter time limits)
8. Unit tests verify difficulty adjustment logic

## Tasks / Subtasks

- [ ] Define difficulty types and parameters (AC: 1)
  - [ ] Create `GameDifficulty` type in `/types/game.ts`: `'easy' | 'medium' | 'hard'`
  - [ ] Create `DifficultySettings` interface with parameters:
    - `timeLimit: number | null`
    - `hintsAvailable: number`
    - `complexity: number` (e.g., how many letters to hide)
  - [ ] Define default settings for each difficulty level

- [ ] Create difficulty adjustment algorithm (AC: 3, 4, 5)
  - [ ] Create file `/lib/algorithms/difficulty-adjustment.ts`
  - [ ] Implement `calculateDifficulty(recentResults: GameResult[]): GameDifficulty`
  - [ ] Look at last 3-5 game attempts for the word
  - [ ] Count consecutive successes and failures
  - [ ] Adjustment rules:
    - 3+ consecutive correct → increase difficulty (easy→medium, medium→hard)
    - 2+ consecutive incorrect → decrease difficulty (hard→medium, medium→easy)
    - Mixed results → maintain current difficulty
  - [ ] Never jump more than one level at a time

- [ ] Implement success rate targeting (AC: 6)
  - [ ] Calculate rolling success rate over last 10 games
  - [ ] Target: 70-80% success rate
  - [ ] If success rate > 85% → nudge difficulty up
  - [ ] If success rate < 60% → nudge difficulty down
  - [ ] Prevent oscillation with hysteresis (require 2-3 games at boundary)

- [ ] Define game-specific difficulty parameters (AC: 7)
  - [ ] **Word Scramble**:
    - Easy: No time limit, 3 hints
    - Medium: 90s time limit, 2 hints
    - Hard: 60s time limit, 1 hint
  - [ ] **Missing Letters**:
    - Easy: 1-2 letters missing, show word length
    - Medium: 2-3 letters missing, show word length
    - Hard: 3-4 letters missing, no hints
  - [ ] **Letter Matching**:
    - Easy: Letters stay in place once correct
    - Medium: Can swap letters but with penalty
    - Hard: Must get all correct before checking
  - [ ] **Spelling Challenge**:
    - Easy: Word shown for 5 seconds, unlimited attempts
    - Medium: Word shown for 3 seconds, 3 attempts
    - Hard: Word shown for 2 seconds, 1 attempt

- [ ] Update game components to accept difficulty prop (AC: 1, 7)
  - [ ] Update `GameMechanic` interface in `/types/game.ts`:
    ```typescript
    interface GameMechanicProps {
      word: string
      difficulty: GameDifficulty
      onComplete: (result: GameResult) => void
    }
    ```
  - [ ] Update each game component from Epic 3:
    - `/games/word-scramble/WordScramble.tsx`
    - `/games/missing-letters/MissingLetters.tsx`
    - `/games/letter-matching/LetterMatching.tsx`
    - `/games/spelling-challenge/SpellingChallenge.tsx`
  - [ ] Apply difficulty settings within each component

- [ ] Integrate with AdaptiveEngineMachine (AC: 2, 3)
  - [ ] Add `currentDifficulty` to machine context
  - [ ] Create `adjustDifficulty` service in machine
  - [ ] Call difficulty adjustment after updating confidence
  - [ ] Pass difficulty to GameSessionMachine when selecting word

- [ ] Add difficulty tracking and logging
  - [ ] Store difficulty level in GameResult
  - [ ] Log difficulty adjustments: `{ word, oldDifficulty, newDifficulty, reason }`
  - [ ] Track difficulty distribution for analytics

- [ ] Create comprehensive unit tests (AC: 8)
  - [ ] Create test file `/lib/algorithms/difficulty-adjustment.test.ts`
  - [ ] Test: 3 consecutive correct increases difficulty
  - [ ] Test: 2 consecutive incorrect decreases difficulty
  - [ ] Test: Mixed results maintain difficulty
  - [ ] Test: Difficulty doesn't jump more than one level
  - [ ] Test: Success rate >85% nudges up
  - [ ] Test: Success rate <60% nudges down
  - [ ] Test: Hysteresis prevents oscillation
  - [ ] Run tests with `npm run test`

## Dev Notes

### Architecture Context

**File Structure:**
```
lib/
├── algorithms/
│   ├── difficulty-adjustment.ts       # Difficulty algorithm
│   ├── difficulty-adjustment.test.ts  # Unit tests
```

**Difficulty Philosophy:**
[Source: docs/prd.md#Epic 4 - Story 4.6]

The goal is to keep children in the "Zone of Proximal Development":
- Too easy → boredom, disengagement
- Too hard → frustration, giving up
- Just right → challenge + success = flow state

Target: 70-80% success rate (child feels successful but challenged)

**Difficulty Levels:**
```typescript
type GameDifficulty = 'easy' | 'medium' | 'hard'

interface DifficultySettings {
  timeLimit: number | null  // seconds, null = no limit
  hintsAvailable: number
  complexity: number        // game-specific (e.g., letters to hide)
}

const DIFFICULTY_PRESETS: Record<GameDifficulty, DifficultySettings> = {
  easy: {
    timeLimit: null,
    hintsAvailable: 3,
    complexity: 1
  },
  medium: {
    timeLimit: 90,
    hintsAvailable: 2,
    complexity: 2
  },
  hard: {
    timeLimit: 60,
    hintsAvailable: 1,
    complexity: 3
  }
}
```

**Adjustment Algorithm:**
```typescript
function calculateDifficulty(
  recentResults: GameResult[],
  currentDifficulty: GameDifficulty
): GameDifficulty {
  // Get last 3-5 attempts
  const recent = recentResults.slice(-5)

  if (recent.length < 3) {
    return currentDifficulty // Not enough data
  }

  // Count consecutive at end
  let consecutiveCorrect = 0
  let consecutiveIncorrect = 0

  for (let i = recent.length - 1; i >= 0; i--) {
    if (recent[i].isCorrect) {
      if (consecutiveIncorrect > 0) break
      consecutiveCorrect++
    } else {
      if (consecutiveCorrect > 0) break
      consecutiveIncorrect++
    }
  }

  // Adjustment logic
  if (consecutiveCorrect >= 3 && currentDifficulty !== 'hard') {
    return increaseDifficulty(currentDifficulty)
  }

  if (consecutiveIncorrect >= 2 && currentDifficulty !== 'easy') {
    return decreaseDifficulty(currentDifficulty)
  }

  return currentDifficulty
}

function increaseDifficulty(current: GameDifficulty): GameDifficulty {
  return current === 'easy' ? 'medium' : 'hard'
}

function decreaseDifficulty(current: GameDifficulty): GameDifficulty {
  return current === 'hard' ? 'medium' : 'easy'
}
```

**Game Component Integration:**
```typescript
// Example: WordScramble with difficulty
export function WordScramble({ word, difficulty, onComplete }: GameMechanicProps) {
  const settings = DIFFICULTY_PRESETS[difficulty]

  return (
    <div>
      {settings.timeLimit && <Timer seconds={settings.timeLimit} />}
      <ScrambledWord word={word} hintsAvailable={settings.hintsAvailable} />
      {/* Game implementation */}
    </div>
  )
}
```

### Dependencies

**Required:**
- Story 4.1 (Confidence Scoring) - Provides GameResult data
- Story 4.2 (Adaptive Engine Machine) - Integration point
- Epic 3 (Core Game Mechanics Part 1) - Games to update

**Future Integration:**
- Epic 5 (Core Game Mechanics Part 2) - New games will also support difficulty

### Testing

[Source: docs/ui-architecture.md#Testing Strategy]

**Testing Framework:** Vitest
**Test Location:** `/lib/algorithms/difficulty-adjustment.test.ts`
**Coverage Target:** 70%+

**Test Scenarios:**
```typescript
import { describe, it, expect } from 'vitest'
import { calculateDifficulty } from './difficulty-adjustment'

describe('Dynamic Difficulty Adjustment', () => {
  it('increases difficulty after 3 consecutive correct', () => {
    const results = [
      { isCorrect: true },
      { isCorrect: true },
      { isCorrect: true }
    ]

    const newDifficulty = calculateDifficulty(results, 'easy')
    expect(newDifficulty).toBe('medium')
  })

  it('decreases difficulty after 2 consecutive incorrect', () => {
    const results = [
      { isCorrect: false },
      { isCorrect: false }
    ]

    const newDifficulty = calculateDifficulty(results, 'hard')
    expect(newDifficulty).toBe('medium')
  })

  it('maintains difficulty with mixed results', () => {
    const results = [
      { isCorrect: true },
      { isCorrect: false },
      { isCorrect: true }
    ]

    const newDifficulty = calculateDifficulty(results, 'medium')
    expect(newDifficulty).toBe('medium')
  })

  it('does not jump more than one level', () => {
    const results = Array(10).fill({ isCorrect: true })

    let difficulty: GameDifficulty = 'easy'
    difficulty = calculateDifficulty(results, difficulty)
    expect(difficulty).toBe('medium') // Not 'hard'
  })
})
```

**Run Tests:**
```bash
npm run test
npm run test:coverage
```

### Technical Constraints

- Pure function for difficulty calculation
- TypeScript strict mode
- Performance: Calculation should execute in <5ms
- Smooth progression: No abrupt difficulty spikes
- Game-agnostic: Core algorithm works for all games

### Previous Story Insights

From Story 4.1 (Confidence Scoring):
- Use GameResult data structure
- Recent performance tracking patterns

From Story 4.2 (Adaptive Engine Machine):
- Difficulty stored in machine context
- Adjusted after confidence updates

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.0 | Initial story created | Sarah (PO) |

## Dev Agent Record

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes List

_To be populated by dev agent_

### File List

_To be populated by dev agent_

## QA Results

_To be populated by QA agent_
